1.  Which one of your three solutions was the ​ easiest for you ​ to write? Why?

The decorator pattern was the easiest for me to write for the following reason: I had already mostly solved the actual business logic of solving the problem using the Template Method pattern and was familiar with the Decorator Pattern from the previous two labs. As a result the Decorator was the easiest for me to write.

2.  Having done all the previous work, suppose you now also wanted to create a turtle that lays eggs while it draws its path in a hand drawn style, as in the ​ HandDrawnTurtle example class that you already have.  Which one of your three solutions would best accommodate this feature request?  Why?

I think you could do this easily enough by using the Decorator pattern: Instantiate an EggLayingTurtle that decorates a HandDrawnTurtle. My understanding of the Decorator Pattern is that we can extend objects' functionality or features marginally and then make many combinations of these enhancements without having to manually create as many sub-classes as there are combinations. For example, to create the above turtle with the Template Pattern you could extend a sub-class from HandDrawnTurtle and then implement your Egg logic but if you wanted to have a SkippingTurtle that also laid eggs you would have to do the same for SkippingTurtle; extend a sub-class and then implement your egg logic. This would be a bad code smell.

3.  Having done all the previous work, suppose you now also wanted to create a class SnappingTurtle that, instead of laying eggs, outputs the message “snap snap” on the console after each time it moves.  Which one of your three solutions would accommodate this feature request best? Why?

I think the Strategy Pattern would make this implementation quite simple: Create a new Action, perhaps SnapAction, and pass it to the ActionTurtle. I think it would be the easiest because you could re-use most of your code and by creating a new action in a moment, with a few lines, accomodate this feature. You could have the turtle do many things with this logic.

4.  What general principles of object oriented design can you infer from your answers to the first three questions?

Design Patterns are important to learn and understand in order to maintain your code as your project grows in size and complexity. There are many advantages to be had by these patterns such as improved code re-usability, minimized repetition, and reduced bugs (although I don't have any first hand experience of bug reduction at this stage of my understanding). Implementing these patterns is straightforward and becomes more so with practice. These design patterns also highlight some of the advantages of Polymorphism, Inheritance and Object-oriented Programming in general. There was some discussion on Hacker News a while ago about how many programming problems are averted or solved beforehand by working things out on paper before you touch a keyboard. This course nicely supports that argument by highlighting the advantages of programming design; solving the complexities of your code before you write it will (hopefully) save time in the long-run.  
